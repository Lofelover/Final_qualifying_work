# Веб-приложение с микрофронтенд-архитектурой

## Описание проекта
Этот проект представляет собой выпускную квалификационную работу бакалавра на тему **"Оптимизация производительности веб-приложения с использованием микрофронтендов"**,

Цель проекта — разработка масштабируемого и производительного веб-приложения с использованием микрофронтенд-архитектуры, включающего модули каталога товаров, корзины покупок и профиля пользователя. Приложение реализовано с применением современных технологий и методов оптимизации производительности, таких как ленивая загрузка, кэширование и минимизация перерисовок.

## Основные особенности
- **Микрофронтенд-архитектура**: Приложение разделено на независимые модули (каталог, корзина, профиль), которые разрабатываются, тестируются и развертываются отдельно.
- **Технологии**: Использованы React, Webpack Module Federation и React Router для реализации модульной структуры и навигации.
- **Оптимизация производительности**: Применены методы ленивой загрузки, кэширования данных в `localStorage` и минимизации перерисовок с помощью `React.memo`, `useMemo` и `useCallback`.
- **Метрики производительности**: Использованы инструменты Lighthouse и Web Vitals для измерения метрик LCP, FID и TTI, что позволило достичь улучшения производительности на 45% (среднее снижение TTI и LCP).

## Структура проекта
Проект состоит из следующих ключевых компонентов:
- **Catalog.js**: Модуль каталога товаров, обеспечивающий отображение списка товаров, поиск, фильтрацию и пагинацию. Загружает данные с внешнего API (`fakestoreapi.com`).
- **Cart.js**: Модуль корзины покупок, позволяющий добавлять/удалять товары, изменять их количество и рассчитывать общую стоимость.
- **Profile.js**: Модуль профиля пользователя, предоставляющий интерфейс для просмотра и редактирования личных данных.
- **CartContext.js**: Контекст для управления состоянием корзины, синхронизирующий данные между модулями и сохраняющий их в `localStorage`.
- **App.js**: Основной компонент, объединяющий микрофронтенды через React Router и реализующий ленивую загрузку с помощью `React.lazy` и `Suspense`.
- **Webpack.config.js**: Конфигурация Webpack Module Federation для динамической загрузки модулей и управления общими зависимостями.

### Архитектура
Приложение построено на микрофронтенд-архитектуре:
- Каждый модуль (каталог, корзина, профиль) является независимым микрофронтендом.
- **Webpack Module Federation** обеспечивает динамическую загрузку модулей и предотвращает дублирование общих библиотек (React, ReactDOM).
- **React Router** управляет навигацией между модулями, обеспечивая плавные переходы без перезагрузки страницы.
- **CartContext** синхронизирует состояние корзины между модулями и сохраняет данные в `localStorage`.

## Методы оптимизации
Для повышения производительности были реализованы следующие подходы:
1. **Ленивая загрузка**:
   - Компоненты загружаются только при необходимости с помощью `React.lazy` и `Suspense` (см. `App.js`).
   - Пример: Модуль корзины загружается только при переходе на маршрут `/cart`.
2. **Кэширование**:
   - Состояние корзины и профиля сохраняется в `localStorage` для минимизации сетевых запросов (см. `CartContext.js`, `Profile.js`).
   - Статические ресурсы кэшируются с помощью HTTP-заголовков и уникальных имен файлов, генерируемых Webpack.
3. **Минимизация перерисовок**:
   - Использованы `React.memo` для предотвращения лишних рендеров компонентов (`Cart.js`, `Profile.js`).
   - `useMemo` и `useCallback` оптимизируют вычисления и обработчики событий (например, расчет общей стоимости в `Cart.js`).

## Метрики производительности
Производительность оценивалась с помощью инструментов **Lighthouse** и **Web Vitals**:
- **LCP (Largest Contentful Paint)**: Сокращено на 19–54% за счет ленивой загрузки и оптимизации изображений.
- **TTI (Time to Interactive)**: Улучшено на 21–70% благодаря кэшированию и минимизации перерисовок.
- **FID (First Input Delay)**: Незначительные изменения (в пределах 5%), так как основное внимание уделялось LCP и TTI.

TTI измеряется с использованием API Performance (`performance.getEntriesByType('navigation')`) в каждом модуле для оценки времени полной загрузки страницы.

## Установка и запуск
1. Убедитесь, что у вас установлены Node.js и npm.
2. Склонируйте репозиторий:
   ```bash
   git clone <URL_репозитория>
   ```
3. Установите зависимости:
   ```bash
   npm install
   ```
4. Запустите проект:
   ```bash
   npm start
   ```
5. Откройте приложение в браузере по адресу `http://localhost:3002`.

## Тестирование
- **Jest**: Использован для модульного тестирования компонентов и бизнес-логики (например, расчет стоимости в корзине).
- **Cypress**: Применен для end-to-end тестирования пользовательских сценариев (добавление товаров, навигация).
- **Lighthouse**: Проведен аудит производительности для всех модулей.

## Результаты
- Разработано масштабируемое веб-приложение с микрофронтенд-архитектурой.
- Достигнуто улучшение производительности на 45% по ключевым метрикам (LCP, TTI).
- Реализована независимая разработка и развертывание модулей, что упрощает масштабирование и поддержку.

## Использованные источники
1. Google Developers. Core Web Vitals. [https://web.dev/vitals/](https://web.dev/vitals/)
2. Документация Webpack. Module Federation. [https://webpack.js.org/concepts/module-federation/](https://webpack.js.org/concepts/module-federation/)
3. React официальная документация. Оптимизация производительности. [https://reactjs.org/docs/optimizing-performance.html](https://reactjs.org/docs/optimizing-performance.html)
